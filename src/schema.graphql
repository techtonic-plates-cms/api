scalar JSON

"""
A content collection that groups related entries together with a defined schema.
Collections serve as containers for structured data with customizable fields.
"""
type Collection {
  "Unique identifier for the collection"
  id: ID!
  "Human-readable name of the collection"
  name: String!
  "URL-friendly identifier used for routing and references"
  slug: String!
  "Optional description explaining the purpose of this collection"
  description: String
  "Schema definition - list of fields that define the structure of entries in this collection"
  fields: [Field!]!
  "All entries belonging to this collection, with optional filtering"
  entries(filter: EntryFilter): [Entry!]!
  "Username or ID of the user who created this collection"
  createdBy: String
  "ISO 8601 timestamp when the collection was created"
  createdAt: String
  "ISO 8601 timestamp when the collection was last modified"
  updatedAt: String
}

"""
A single record or content item within a collection.
Entries contain the actual data values that conform to their collection's schema.
"""
type Entry {
  "Unique identifier for the entry"
  id: ID!
  "Human-readable name or title of the entry"
  name: String!
  "Optional URL-friendly identifier for the entry"
  slug: String
  "Current status of the entry (e.g., draft, published, archived)"
  status: String!
  "ISO 8601 timestamp when the entry was created"
  createdAt: String!
  "ISO 8601 timestamp when the entry was last modified"
  updatedAt: String!
  "Retrieve the value of a specific field by name, with optional filtering"
  field(name: String!, filter: FieldFilter): FieldValue
}

"""
A field definition that specifies the structure and constraints for data in a collection.
Fields define what types of data can be stored and how they should be validated.
"""
type Field {
  "Unique identifier for the field"
  id: ID!
  "Technical name of the field, used for data storage and API access"
  name: String!
  "Human-readable display label for the field"
  label: String
  "The data type that this field accepts"
  dataType: DataType!
  "Whether this field must have a value when creating or updating entries"
  isRequired: Boolean!
  "Whether values for this field must be unique across all entries in the collection"
  isUnique: Boolean!
}

"""
Supported data types for collection fields.
Each type defines how data is stored, validated, and queried.
"""
enum DataType {
  "Plain text content"
  TEXT
  "Typst markup text with raw and rendered versions"
  TYPST_TEXT
  "True/false boolean value"
  BOOLEAN
  "Numeric integer value"
  NUMBER
  "ISO 8601 date and time string"
  DATE_TIME
  "Reference to another entry in the system"
  RELATION
  "Complex nested object structure"
  OBJECT
  "Array of text strings"
  TEXT_LIST
  "Array of numeric values"
  NUMBER_LIST
  "File upload with metadata"
  ASSET
  "Formatted text with markup (HTML, Markdown, etc.)"
  RICH_TEXT
  "Arbitrary JSON data with type information"
  JSON
}

"""
Union of all possible field value types.
The actual type returned depends on the field's DataType definition.
"""
union FieldValue = Text | TypstText | Asset | BooleanValue | NumberValue | DateTime | RichText | Json | Relation

"""
Plain text field value container.
"""
type Text {
  "The text content"
  text: String
}

"""
Typst markup text with both raw source and rendered output.
Typst is a modern typesetting language for scientific documents.
"""
type TypstText {
  "Raw Typst markup source code"
  raw: String!
  "Rendered output (HTML, PDF, or other format)"
  rendered: String!
}

"""
Reference to another entry in the system.
Enables relationships between different content items.
"""
type Relation {
  "The referenced entry"
  entry: Entry
}

"""
File asset with metadata and storage information.
Represents uploaded files like images, documents, videos, etc.
"""
type Asset {
  "Unique identifier for the asset"
  id: ID!
  "Storage path or URL to the file"
  path: String!
  "Original filename when uploaded"
  filename: String!
  "MIME type of the file (e.g., image/jpeg, application/pdf)"
  mimeType: String!
  "File size in bytes"
  fileSize: Int!
  "Alternative text for accessibility"
  alt: String
  "Optional caption or description"
  caption: String
}

"""
Boolean value container for true/false fields.
"""
type BooleanValue {
  "The boolean value"
  value: Boolean
}

"""
Numeric value container for integer fields.
"""
type NumberValue {
  "The numeric value"
  value: Int
}

"""
Date and time value container.
"""
type DateTime {
  "ISO 8601 formatted date/time string"
  value: String
}

"""
Rich text content with formatting and markup support.
Supports various formats like HTML, Markdown, etc.
"""
type RichText {
  "Raw source content with markup"
  raw: String!
  "Rendered HTML or formatted output"
  rendered: String!
  "Format type (html, markdown, etc.)"
  format: String!
}

"""
JSON data container with type information.
Stores arbitrary structured data as JSON strings.
"""
type Json {
  "JSON-encoded string representation of the data"
  value: String!
  "Type information about the JSON structure"
  valueType: String!
}

"""
Filtering options for text field values.
Supports various string matching operations.
"""
input TextFilter {
  "Exact match"
  eq: String
  "Not equal to"
  ne: String
  "Contains substring"
  contains: String
  "Starts with prefix"
  startsWith: String
  "Ends with suffix"
  endsWith: String
  "Value is in the provided list"
  in: [String!]
  "Value is not in the provided list"
  notIn: [String!]
}

"""
Filtering options for numeric field values.
Supports comparison and range operations.
"""
input NumberFilter {
  "Exactly equal to"
  eq: Int
  "Not equal to"
  ne: Int
  "Greater than"
  gt: Int
  "Greater than or equal to"
  gte: Int
  "Less than"
  lt: Int
  "Less than or equal to"
  lte: Int
  "Value is in the provided list"
  in: [Int!]
  "Value is not in the provided list"
  notIn: [Int!]
}

"""
Filtering options for boolean field values.
"""
input BooleanFilter {
  "Exactly equal to (true or false)"
  eq: Boolean
  "Not equal to"
  ne: Boolean
}

"""
Filtering options for date/time field values.
All dates should be provided as ISO 8601 strings.
"""
input DateTimeFilter {
  "Exactly equal to this date/time"
  eq: String
  "Not equal to this date/time"
  ne: String
  "After this date/time"
  gt: String
  "On or after this date/time"
  gte: String
  "Before this date/time"
  lt: String
  "On or before this date/time"
  lte: String
}

"""
Filtering options for asset field values.
Allows filtering on asset metadata properties.
"""
input AssetFilter {
  "Filter by filename"
  filename: TextFilter
  "Filter by MIME type"
  mimeType: TextFilter
  "Filter by file size in bytes"
  fileSize: NumberFilter
  "Filter by alt text"
  alt: TextFilter
  "Filter by caption"
  caption: TextFilter
}

"""
Filtering options for rich text field values.
Allows filtering on both raw and rendered content.
"""
input RichTextFilter {
  "Filter by raw source content"
  raw: TextFilter
  "Filter by rendered HTML content"
  rendered: TextFilter
  "Filter by format type"
  format: TextFilter
}

"""
Filtering options for JSON field values.
Currently supports filtering by value type, with room for expansion.
"""
input JsonFilter {
  "Filter by the type of JSON structure stored"
  valueType: TextFilter
}

"""
Filtering options for Typst text field values.
Allows filtering on both source and rendered content.
"""
input TypstTextFilter {
  "Filter by raw Typst source code"
  raw: TextFilter
  "Filter by rendered output content"
  rendered: TextFilter
}

"""
Filtering options for relation field values.
Allows filtering by properties of the referenced entry.
"""
input RelationFilter {
  "Filter by the ID of the referenced entry"
  entryId: String
  "Filter by the name of the referenced entry"
  entryName: TextFilter
  "Filter by the status of the referenced entry"
  entryStatus: String
}

"""
Unified filter input that can contain filters for any field type.
Only the filter matching the field's data type will be applied.
"""
input FieldFilter @oneOf {
  "Filter for text fields"
  text: TextFilter
  "Filter for Typst text fields"
  typstText: TypstTextFilter
  "Filter for number fields"
  number: NumberFilter
  "Filter for boolean fields"
  boolean: BooleanFilter
  "Filter for date/time fields"
  dateTime: DateTimeFilter
  "Filter for asset fields"
  asset: AssetFilter
  "Filter for rich text fields"
  richText: RichTextFilter
  "Filter for JSON fields"
  json: JsonFilter
  "Filter for relation fields"
  relation: RelationFilter
}

"""
Filtering options for entries within a collection.
Allows filtering by basic entry properties.
"""
input EntryFilter {
  "Filter by entry name (exact match)"
  name: String
  "Filter by entry status"
  status: String
}


"""
Input for creating a new field within a collection.
Defines the structure and constraints for the field.
"""
input CreateFieldInput {
  "Technical name for the field (used in API calls)"
  name: String!
  "Human-readable display label"
  label: String
  "Data type that this field will store"
  dataType: DataType!
  "Whether the field must have a value (defaults to false)"
  isRequired: Boolean! = false
  "Whether field values must be unique across entries (defaults to false)"
  isUnique: Boolean! = false
}

"""
Input for creating a new collection with its field definitions.
Defines the collection metadata and schema structure.
"""
input CreateCollectionInput {
  "Human-readable name for the collection"
  name: String!
  "URL-friendly identifier for the collection"
  slug: String!
  "Optional description explaining the collection's purpose"
  description: String
  "Optional icon identifier for UI display"
  icon: String
  "Optional color code for UI theming"
  color: String
  "Default locale for content (defaults to 'en')"
  defaultLocale: String = "en"
  "List of supported locales for internationalization (defaults to ['en'])"
  supportedLocales: [String!] = ["en"]
  "Whether this collection supports multiple languages (defaults to false)"
  isLocalized: Boolean! = false
  "Field definitions that define the collection's schema"
  fields: [CreateFieldInput!]!
}

"""
Input for TEXT field values.
"""
input TextFieldInput {
  "Plain text string value"
  value: String!
}

"""
Input for TYPST_TEXT field values.
"""
input TypstTextFieldInput {
  "Raw Typst markup source code"
  raw: String!
  "Rendered output (HTML, PDF, or other format)"
  rendered: String!
}

"""
Input for BOOLEAN field values.
"""
input BooleanFieldInput {
  "Boolean value"
  value: Boolean!
}

"""
Input for NUMBER field values.
"""
input NumberFieldInput {
  "Integer value"
  value: Int!
}

"""
Input for DATE_TIME field values.
"""
input DateTimeFieldInput {
  "ISO 8601 formatted date/time string"
  value: String!
}

"""
Input for RELATION field values.
"""
input RelationFieldInput {
  "UUID of the entry to reference"
  entryId: ID!
}

"""
Input for ASSET field values.
"""
input AssetFieldInput {
  "UUID of the asset to reference"
  assetId: ID!
}

"""
Input for RICH_TEXT field values.
"""
input RichTextFieldInput {
  "Raw source content with markup"
  raw: String!
  "Rendered HTML or formatted output"
  rendered: String!
  "Format type (defaults to 'markdown')"
  format: String = "markdown"
}

"""
Input for OBJECT field values.
"""
input ObjectFieldInput {
  "JSON-encoded string representation of the object"
  value: JSON!
}

"""
Input for TEXT_LIST field values.
"""
input TextListFieldInput {
  "Array of text strings"
  value: [String!]!
}

"""
Input for NUMBER_LIST field values.
"""
input NumberListFieldInput {
  "Array of integer values"
  value: [Int!]!
}

"""
Input for JSON field values.
"""
input JsonFieldInput {
  "Arbitrary JSON data"
  value: JSON!
}

"""
Union of all possible field value input types.
Use the input type that matches your field's DataType.
"""
input CreateEntryFieldValueInput @oneOf {
  "Value for TEXT fields"
  text: TextFieldInput
  "Value for TYPST_TEXT fields"
  typstText: TypstTextFieldInput
  "Value for BOOLEAN fields"
  boolean: BooleanFieldInput
  "Value for NUMBER fields"
  number: NumberFieldInput
  "Value for DATE_TIME fields"
  dateTime: DateTimeFieldInput
  "Value for RELATION fields"
  relation: RelationFieldInput
  "Value for ASSET fields"
  asset: AssetFieldInput
  "Value for RICH_TEXT fields"
  richText: RichTextFieldInput
  "Value for OBJECT fields"
  object: ObjectFieldInput
  "Value for TEXT_LIST fields"
  textList: TextListFieldInput
  "Value for NUMBER_LIST fields"
  numberList: NumberListFieldInput
  "Value for JSON fields"
  json: JsonFieldInput
}

"""
Represents a field value for creating an entry.
The field name must correspond to a field defined in the collection schema.
The value input must match the field's DataType.
"""
input CreateEntryFieldInput {
  "Name of the field as defined in the collection schema"
  field: String!
  "Typed value input that must match the field's DataType"
  value: CreateEntryFieldValueInput!
}

"""
Input for creating a new entry in a collection.
Defines the entry metadata and field values.
"""
input CreateEntryInput {
  "Human-readable name or title of the entry"
  name: String!
  "Name of the collection this entry belongs to"
  collectionName: String!
  "Optional URL-friendly identifier for the entry"
  slug: String
  "Entry status (defaults to 'DRAFT')"
  status: String = "DRAFT"
  "Locale for this entry (defaults to 'en')"
  locale: String = "en"
  "Default locale for this entry group (defaults to 'en')"
  defaultLocale: String = "en"
  "Field values for this entry"
  fields: [CreateEntryFieldInput!]!
}

"""
Root query type that defines all available read operations.
Clients use these queries to fetch data from the API.
"""
type Query {
  "Retrieve a specific collection by its name"
  collection(name: String!): Collection

  # User Management Queries
  "Get current authenticated user"
  me: User
  "Get a specific user by ID"
  user(id: ID!): User
  "List all users (requires admin permissions)"
  users: [User!]!

  # Role Management Queries
  "Get a specific role by ID"
  role(id: ID!): Role
  "List all roles"
  roles: [Role!]!

  # Policy Management Queries
  "Get a specific policy by ID"
  policy(id: ID!): Policy
  "List all policies (requires admin permissions)"
  policies: [Policy!]!
}

"""
Represents a user in the CMS system.
"""
type User {
  "Unique identifier for the user"
  id: ID!
  "Username for the user"
  name: String!
  "Current status of the user account"
  status: UserStatus!
  "When the user account was created"
  creationTime: String!
  "When the user last logged in"
  lastLoginTime: String!
  "When the user account was last modified"
  lastEditTime: String!
  "Roles assigned to this user"
  roles: [Role!]!
  "Direct policies assigned to this user"
  policies: [Policy!]!
}

"""
User account status options.
"""
enum UserStatus {
  ACTIVE
  INACTIVE
  BANNED
}

"""
Represents a role that groups permissions together.
"""
type Role {
  "Unique identifier for the role"
  id: ID!
  "Name of the role"
  name: String!
  "Description explaining the role's purpose"
  description: String
  "When the role was created"
  creationTime: String!
  "When the role was last modified"
  lastEditTime: String!
  "Policies assigned to this role"
  policies: [Policy!]!
}

"""
Represents an ABAC policy that defines access rules.
"""
type Policy {
  "Unique identifier for the policy"
  id: ID!
  "Name of the policy"
  name: String!
  "Description of what this policy controls"
  description: String
  "Whether the policy allows or denies access"
  effect: PolicyEffect!
  "Priority for conflict resolution (higher number = higher priority)"
  priority: Int!
  "Whether the policy is currently active"
  isActive: Boolean!
  "Type of resource this policy applies to"
  resourceType: ResourceType!
  "Type of action this policy controls"
  actionType: ActionType!
  "How rules within this policy are combined"
  ruleConnector: LogicalOperator!
  "Rules that define the conditions for this policy"
  rules: [PolicyRule!]!
  "User who created this policy"
  createdBy: User!
  "When the policy was created"
  createdAt: String!
  "When the policy was last updated"
  updatedAt: String!
}

"""
Policy effect determines whether access is granted or denied.
"""
enum PolicyEffect {
  ALLOW
  DENY
}

"""
Types of resources that can be controlled by policies.
"""
enum ResourceType {
  users
  collections
  entries
  assets
  fields
}

"""
Types of actions that can be performed on resources.
"""
enum ActionType {
  create
  read
  update
  delete
  publish
  unpublish
  schedule
  archive
  restore
  draft
  ban
  unban
  activate
  deactivate
  upload
  download
  transform
  configure_fields
  manage_schema
}

"""
Logical operators for combining policy rules.
"""
enum LogicalOperator {
  AND
  OR
}

"""
Individual rule within a policy that checks specific conditions.
"""
type PolicyRule {
  "Unique identifier for the rule"
  id: ID!
  "Attribute path this rule checks"
  attributePath: String!
  "Comparison operator"
  operator: RuleOperator!
  "Expected value for comparison"
  expectedValue: String!
  "Type of the expected value"
  valueType: ValueType!
  "Description of what this rule checks"
  description: String
  "Whether the rule is active"
  isActive: Boolean!
  "Order of evaluation within the policy"
  order: Int!
  "When the rule was created"
  createdAt: String!
}

"""
Operators for comparing values in policy rules.
"""
enum RuleOperator {
  eq
  ne
  in
  not_in
  gt
  gte
  lt
  lte
  contains
  starts_with
  ends_with
  is_null
  is_not_null
  regex
}

"""
Value types for policy rule comparisons.
"""
enum ValueType {
  string
  number
  boolean
  uuid
  datetime
  array
}

"""
Input for creating a new user.
"""
input CreateUserInput {
  "Username for the new user"
  name: String!
  "Password for the new user (will be hashed)"
  password: String!
  "Initial status for the user account"
  status: UserStatus = ACTIVE
}

"""
Input for updating user information.
"""
input UpdateUserInput {
  "New username (optional)"
  name: String
  "New password (optional, will be hashed)"
  password: String
  "New status (optional)"
  status: UserStatus
}

"""
Input for updating current user's profile.
"""
input UpdateMyProfileInput {
  "New username"
  name: String!
}

"""
Input for changing current user's password.
"""
input ChangeMyPasswordInput {
  "Current password for verification"
  currentPassword: String!
  "New password"
  newPassword: String!
}

"""
Input for creating a new role.
"""
input CreateRoleInput {
  "Name for the new role"
  name: String!
  "Description of the role's purpose"
  description: String
}

"""
Input for updating role information.
"""
input UpdateRoleInput {
  "New name for the role"
  name: String
  "New description for the role"
  description: String
}

"""
Input for creating a policy rule.
"""
input CreatePolicyRuleInput {
  "Attribute path to check"
  attributePath: String!
  "Comparison operator"
  operator: RuleOperator!
  "Expected value for comparison"
  expectedValue: String!
  "Type of the expected value"
  valueType: ValueType!
  "Description of the rule"
  description: String
  "Order of evaluation (defaults to 0)"
  order: Int = 0
}

"""
Input for creating a new ABAC policy.
"""
input CreatePolicyInput {
  "Name for the new policy"
  name: String!
  "Description of what this policy controls"
  description: String
  "Whether the policy allows or denies access"
  effect: PolicyEffect!
  "Priority for conflict resolution"
  priority: Int = 100
  "Type of resource this policy applies to"
  resourceType: ResourceType!
  "Type of action this policy controls"
  actionType: ActionType!
  "How rules are combined (defaults to AND)"
  ruleConnector: LogicalOperator = AND
  "Rules that define the conditions"
  rules: [CreatePolicyRuleInput!]!
}

"""
Input for updating policy information.
"""
input UpdatePolicyInput {
  "New name for the policy"
  name: String
  "New description"
  description: String
  "New effect"
  effect: PolicyEffect
  "New priority"
  priority: Int
  "New active status"
  isActive: Boolean
  "New rule connector"
  ruleConnector: LogicalOperator
}

"""
Result of user creation operation.
"""
type CreateUserResult {
  "The created user"
  user: User!
  "Success message"
  message: String!
}

"""
Result of role assignment operation.
"""
type AssignRoleResult {
  "The updated user"
  user: User!
  "The assigned role"
  role: Role!
  "Success message"
  message: String!
}

"""
Result of policy assignment operation.
"""
type AssignPolicyResult {
  "Success status"
  success: Boolean!
  "Success or error message"
  message: String!
}

"""
Content management operations for collections and entries.
Handles all content creation, modification, and organization.
"""
type ContentMutations {
  "Create a new collection with schema definition"
  createCollection(input: CreateCollectionInput!): Collection!
  "Create a new entry in a collection"
  createEntry(input: CreateEntryInput!): Entry!
}

"""
Account management operations for the authenticated user.
Provides a clean, organized way to manage user account settings.
"""
type AccountMutations {
  "Update profile information (username, etc.)"
  updateProfile(input: UpdateMyProfileInput!): User!
  "Change account password"
  changePassword(input: ChangeMyPasswordInput!): Boolean!
  "Deactivate this account"
  deactivate(confirmUsername: String!): Boolean!
}

"""
Administrative operations for managing users, roles, and policies.
Requires administrative privileges to access these operations.
"""
type AdminMutations {
  "Access user management operations"
  users: UserManagementMutations!
  "Access role management operations"
  roles: RoleManagementMutations!
  "Access policy management operations"
  policies: PolicyManagementMutations!
}

"""
User management operations for administrators.
"""
type UserManagementMutations {
  "Create a new user account"
  create(input: CreateUserInput!): CreateUserResult!
  "Update user information"
  update(id: ID!, input: UpdateUserInput!): User!
  "Delete a user account"
  delete(id: ID!): Boolean!
  "Change user status (activate, deactivate, ban)"
  changeStatus(id: ID!, status: UserStatus!): User!
  "Assign a role to a user"
  assignRole(userId: ID!, roleId: ID!, expiresAt: String): AssignRoleResult!
  "Remove a role from a user"
  removeRole(userId: ID!, roleId: ID!): Boolean!
}

"""
Role management operations for administrators.
"""
type RoleManagementMutations {
  "Create a new role"
  create(input: CreateRoleInput!): Role!
  "Update role information"
  update(id: ID!, input: UpdateRoleInput!): Role!
  "Delete a role"
  delete(id: ID!): Boolean!
  "Assign a policy to a role"
  assignPolicy(policyId: ID!, roleId: ID!, reason: String, expiresAt: String): AssignPolicyResult!
  "Remove a policy from a role"
  removePolicy(policyId: ID!, roleId: ID!): Boolean!
}

"""
Policy management operations for administrators.
"""
type PolicyManagementMutations {
  "Create a new ABAC policy"
  create(input: CreatePolicyInput!): Policy!
  "Update policy information"
  update(id: ID!, input: UpdatePolicyInput!): Policy!
  "Delete a policy"
  delete(id: ID!): Boolean!
  "Assign a policy directly to a user"
  assignToUser(policyId: ID!, userId: ID!, reason: String!, expiresAt: String): AssignPolicyResult!
  "Remove a direct policy assignment from a user"
  removeFromUser(policyId: ID!, userId: ID!): Boolean!
  "Add a rule to an existing policy"
  addRule(policyId: ID!, rule: CreatePolicyRuleInput!): PolicyRule!
  "Remove a rule from a policy"
  removeRule(policyId: ID!, ruleId: ID!): Boolean!
}

"""
Root mutation type that defines all available write operations.
Organized into logical groups for better discoverability and maintainability.
"""
type Mutation {
  "Content management operations (collections, entries)"
  content: ContentMutations!

  "Account self-management operations for authenticated users"
  account: AccountMutations!

  "Administrative operations (requires admin privileges)"
  admin: AdminMutations!
}
